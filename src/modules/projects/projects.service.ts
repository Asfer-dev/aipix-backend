// src/modules/projects/project.service.ts

import prisma from "../../prisma";

/**
 * List all projects owned by a user
 */
export async function listProjectsForUser(userId: number) {
  return prisma.project.findMany({
    where: { userId },
    orderBy: { createdAt: "desc" },
    // you can uncomment this if you want counts in the list view
    include: {
      _count: {
        select: {
          images: true,
          adCopies: true,
          listings: true,
        },
      },
    },
  });
}

/**
 * Create a new project for a user
 */
export async function createProjectForUser(
  userId: number,
  name: string,
  clientName?: string,
  notes?: string
) {
  const project = await prisma.project.create({
    data: {
      userId,
      name,
      clientName,
      notes,
    },
  });

  return project;
}

/**
 * Get a single project (including its ad copy templates)
 */
export async function getProjectForUser(userId: number, projectId: number) {
  const project = await prisma.project.findFirst({
    where: {
      id: projectId,
      userId,
    },
    include: {
      adCopies: true, // <- NEW: include project-level ad copy variants
    },
  });

  return project;
}

/**
 * Add an image to a project and automatically create the ORIGINAL version
 */
export async function addImageToProject(
  userId: number,
  projectId: number,
  originalUrl: string,
  label?: string
) {
  const project = await prisma.project.findFirst({
    where: {
      id: projectId,
      userId,
    },
  });

  if (!project) {
    throw new Error("PROJECT_NOT_FOUND_OR_FORBIDDEN");
  }

  // 1) create Image
  const image = await prisma.image.create({
    data: {
      projectId: project.id,
      originalUrl,
      label,
    },
  });

  // 2) create ORIGINAL version record
  await prisma.imageVersion.create({
    data: {
      imageId: image.id,
      type: "ORIGINAL",
      url: originalUrl,
    },
  });

  return image;
}

/**
 * List images (with their versions) for a project
 */
export async function listImagesForProject(userId: number, projectId: number) {
  const project = await prisma.project.findFirst({
    where: {
      id: projectId,
      userId,
    },
  });

  if (!project) {
    throw new Error("PROJECT_NOT_FOUND_OR_FORBIDDEN");
  }

  const images = await prisma.image.findMany({
    where: { projectId },
    include: {
      versions: true,
    },
    orderBy: { createdAt: "desc" },
  });

  return images;
}

/**
 * =========================
 * PROJECT AD COPY (templates for any channel / listing)
 * =========================
 */

interface ProjectAdCopyInput {
  channel: string; // e.g. 'generic', 'aipix_marketplace', 'facebook', etc.
  title: string;
  description: string;
  keywords?: string;
}

/**
 * List ad copy variants for a project
 */
export async function listProjectAdCopiesForUser(
  userId: number,
  projectId: number
) {
  const project = await prisma.project.findFirst({
    where: {
      id: projectId,
      userId,
    },
  });

  if (!project) {
    throw new Error("PROJECT_NOT_FOUND_OR_FORBIDDEN");
  }

  return prisma.projectAdCopy.findMany({
    where: { projectId },
    orderBy: { createdAt: "desc" },
  });
}

/**
 * Create a new ad copy variant for a project
 * (could be generated by AI or manually created)
 */
export async function createProjectAdCopyForUser(
  userId: number,
  projectId: number,
  input: ProjectAdCopyInput
) {
  // Confirm project ownership
  const project = await prisma.project.findFirst({
    where: {
      id: projectId,
      userId,
    },
  });

  if (!project) {
    throw new Error("PROJECT_NOT_FOUND_OR_FORBIDDEN");
  }

  const adCopy = await prisma.projectAdCopy.create({
    data: {
      projectId: project.id,
      channel: input.channel,
      title: input.title,
      description: input.description,
      keywords: input.keywords,
      createdById: userId,
    },
  });

  return adCopy;
}

/**
 * Update an existing ad copy variant (only if it belongs to this user's project)
 */
export async function updateProjectAdCopyForUser(
  userId: number,
  projectId: number,
  adCopyId: number,
  input: Partial<ProjectAdCopyInput>
) {
  // First ensure the ad copy belongs to this project AND project belongs to user
  const adCopy = await prisma.projectAdCopy.findFirst({
    where: {
      id: adCopyId,
      projectId,
      project: {
        userId,
      },
    },
  });

  if (!adCopy) {
    throw new Error("AD_COPY_NOT_FOUND_OR_FORBIDDEN");
  }

  const updated = await prisma.projectAdCopy.update({
    where: { id: adCopyId },
    data: {
      channel: input.channel ?? adCopy.channel,
      title: input.title ?? adCopy.title,
      description: input.description ?? adCopy.description,
      keywords: input.keywords ?? adCopy.keywords,
    },
  });

  return updated;
}

/**
 * Delete an ad copy variant from a project
 */
export async function deleteProjectAdCopyForUser(
  userId: number,
  projectId: number,
  adCopyId: number
) {
  // Check ownership
  const adCopy = await prisma.projectAdCopy.findFirst({
    where: {
      id: adCopyId,
      projectId,
      project: {
        userId,
      },
    },
  });

  if (!adCopy) {
    throw new Error("AD_COPY_NOT_FOUND_OR_FORBIDDEN");
  }

  await prisma.projectAdCopy.delete({
    where: { id: adCopyId },
  });

  return { success: true };
}
